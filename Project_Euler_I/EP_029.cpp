// Isaiah Campsall		June 06, 2022		EP_29.cpp
/*
		Consider all integer combinations of a^b 
		if they are then placed in numerical order, with any repeats removed:
		How many distinct terms are in the sequence generated by a^b for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?
*/

#include <EPHeader.h>



int main()
{

	vector<vector<int>> products;
	cout << "Calculating All Powers for Given Range..." << endl;
		long hold = 1;
		int count = 0;
		for (int a = 2; a <= 100; a++) {
			
			cout << ".";
			if (a % 7 == 0) {
				cout << "\r                                                                                                     \r";
			}
			for (int b = 2; b <= 100; b++) {

				products.push_back(a_ToThe_b(a, b));
				if (b % 20 == 0) {
					cout << ".";
				}				
				count++;

			}
		}
		cout << "\r                                                                                                     \r..........";
		
		BubbleSort(products);
		
		cout << "There are " << products.size() << " unique squares in the given range" << endl;	

	return 0;
}


//void SortAndFilter(vector<vector<int>>& array)				//least to greatest
//{
//	bool cnt = false;
//	do {
//		cnt = false;
//		for (int i = 0; i < (array.size() - 1); i++) {
//			if (array[i].size() > array[i + 1].size()) {
//				array[i].swap(array[i + 1]);
//				cnt = true;
//				cout << ".";
//			}
//			if (i % 26 == 0) { cout << "\r                                                                                                    \r"; }
//		}
//	} while (cnt);
//	cout << endl << "Reorganizing and eliminating doubles..." << endl;
//	do {
//		cnt = false;
//		for (int i = 0; i < (array.size() - 1); i++) {
//
//			if ((array[i] > array[i + 1]) && (array[i].size() == array[i + 1].size())) {
//				cout << ".";
//					array[i].swap(array[i + 1]);
//					cnt = true;
//			}
//			if (array[i] == array[i + 1]) {
//				array.erase(array.begin() + i);
//
//					cnt = true;
//			}
//			if (i % 25 == 0) { cout << "\r                                                                                                    \r"; }
//		}
//	} while (cnt);
//
//	cout << "\n";
//
//	for (int i = 0; i < array.size(); i++) {
//		for (int ii = 0; ii < array[i].size(); ii++) {
//			cout << array[i][ii];
//		}
//		cout << "\n\n";
//	}
//
//	
//}
//
//vector<int> a_ToThe_b(int a, int b)			//multi digit * multi digit
//{														
//	vector<int> power = { a };
//	int carry = 0;
//	int cnt = 1;
//	unsigned int OGSize;
//	while (cnt < b) {
//
//		OGSize = power.size();								//vector size is changed through for loop so original (OG) value is retained
//		for (unsigned int i = 0; i < OGSize; i++) {
//
//			while (power[0] >= 10) {
//				carry = power[0] / 10;
//				power.insert(power.begin(), carry);
//				power[1] %= 10;
//				carry = 0;
//				OGSize++;
//			}
//
//			if (*(power.end() - 1 - i)) {					//if the element in the array is not zero
//				*(power.end() - 1 - i) *= a;				//multiply the element by a
//				*(power.end() - 1 - i) += carry;			//add carry to the element
//				if (*(power.end() - 1 - i) >= 10) {			//if the new element is ten or higher
//					carry = *(power.end() - 1 - i) / 10;					//set carry to be the element divided by ten, rounded down to the nearest whole number
//					while (*(power.end() - 1 - i) >= 10) {
//						*(power.end() - 1 - i) %= 10;	//set the element to be the LSB of the current element
//					}
//					if ((power.end() - 1 - i) == power.begin()) {
//						power.insert(power.begin(), carry);
//						carry = 0;
//					}
//
//				}
//				else {
//					carry = 0;				//if the element is less than 10 there is no carry
//				}
//			}
//			else {									//if the element is zero
//				*(power.end() - 1 - i) = carry;			//add carry to the element
//				if (*(power.end() - 1 - i) >= 10) {
//					carry = *(power.end() - 1 - i) / 10;
//					*(power.end() - 1 - i) %= 10;
//				}
//				else { carry = 0; }							//set carry to zero
//			}
//
//			while (power[0] >= 10) {
//				carry = power[0] / 10;
//				power.insert(power.begin(), carry);
//				power[1] %= 10;
//				carry = 0;
//
//			}
//		}
//		cnt++;
//	}
//	return power;
//}

